# 01 - Basic cc_binary

Like in other build systems, in Bazel there is a concept of target. In bazel a target is something that, well, you can target! The first type of target is a file, which can either be a source file or a file generated by Bazel itself. In this example `main.cc` and the executable generated out of it are both targets. This isn't the only type of target though. In bazel there is a second type of target called a rule. A rule is a simple function-like construct that can be instantiated in a `BUILD.bazel` file and used in your target graph. It contains any of the following:
- inputs: other targets that this target needs to be able to build and/or run (like in the case of tests)
- outputs: files that are generated by this rule
- metadata: unlike most build systems, targets in Bazel can generate a number of metadata, which are often read by other rules or Bazel itself to carry out useful functionalities
- actions: individual commands that are executed to generate outputs

Later on, we will be building our very own rules, but most of the time that isn't needed. You can usually find battle tested rules for your language (scala -> rules_scala, js -> rules_js, go -> rules_go, etc.) or tools (containers -> rules_oci, gazelle, etc.) readily available on [BCR](https://registry.bazel.build/)(Bazel Centraly Registry - a registry for Bazel native dependencies) or embedded within Bazel itself. A collection of rules is called `ruleset`. In the following exercises we will be focusing on C++, but don't worry, you won't have to be proficient about C++ at all!

Most language rulesets expose some very similar rules to create libraries (\*_library), binaries (\*_binary)  and run tests (\*_test). We will start with a simple C++ binary built using the rule `cc_binary`.